-- SECURITY FIX: STRICT DATA ISOLATION
-- Date: 2026-01-08
-- Description: Separates access logic for "Public Operational Data" (Trips, Routes) 
-- vs "Private Financial/Internal Data" (Commissions, Ledger, Staff).

BEGIN;

-- 1. Create a STRICT access function for Internal/Private Data
-- This function returns TRUE ONLY if the user is an Admin or a Member of the target partner.
-- It returns FALSE for anonymous users and regular customers.
CREATE OR REPLACE FUNCTION public.can_access_private_data(_target_partner_id BIGINT)
RETURNS BOOLEAN
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    _user_id UUID := auth.uid();
    _role TEXT;
    _user_partner_id INTEGER;
BEGIN
    -- Deny Anonymous
    IF _user_id IS NULL THEN
        RETURN FALSE;
    END IF;

    -- Get Role
    SELECT role::text, partner_id INTO _role, _user_partner_id 
    FROM public.user_roles 
    WHERE user_id = _user_id 
    LIMIT 1;

    -- Deny if no role (Regular Customer)
    IF _role IS NULL THEN
        RETURN FALSE;
    END IF;

    -- Allow Admin
    IF _role = 'admin' THEN
        RETURN TRUE;
    END IF;

    -- Allow Partner/Employee if IDs match
    -- If _target_partner_id is NULL, it implies system-level data (usually admin only), 
    -- but for some tables it might mean "shared". 
    -- However, for commissions/ledger, _target_partner_id should NOT be null.
    -- If it is null, we default to blocking partners to be safe, unless explicit logic exists.
    IF _target_partner_id IS NULL THEN
        RETURN FALSE; 
    END IF;

    RETURN _target_partner_id = _user_partner_id;
END;
$$;

-- 2. Apply Strict Policy to SENSITIVE/PRIVATE Tables
-- These tables should NEVER be visible to the public.

DO $$ 
DECLARE 
    t TEXT;
    -- Private Tables: Financials, Staff, Internal Workflows
    private_tables TEXT[] := ARRAY[
        'commissions', 
        'daily_commissions',
        'booking_ledger', 
        'partner_invoices', 
        'partner_invoice_items', 
        'partner_payments',
        'employees',
        'drivers',
        'booking_approvals' 
    ];
BEGIN
    FOREACH t IN ARRAY private_tables LOOP
        -- Drop old permissive policies
        EXECUTE format('DROP POLICY IF EXISTS "Unified view access for %I" ON public.%I', t, t);
        EXECUTE format('DROP POLICY IF EXISTS "Public read access for %I" ON public.%I', t, t);
        EXECUTE format('DROP POLICY IF EXISTS "Partners/Employees view own company" ON public.%I', t);
        
        -- Apply STRICT access policy
        EXECUTE format('CREATE POLICY "Strict private access for %I" ON public.%I FOR SELECT USING (public.can_access_private_data(partner_id))', t, t);
        
        -- Ensure Write policies also respect partner ownership (usually handled by separate management policies, but good to reinforce)
        -- We won't touch write policies here to avoid "Conflict" or breaking existing management flows, 
        -- assuming "Partners/Employees manage own X" policies exist and are correct.
        -- We focus on patching the READ leak.
    END LOOP;
END $$;


-- 3. Refine PUBLIC Operational Tables
-- Trips, Routes, Branches, Buses NEED to be visible to customers for searching.
-- The previous 'can_view_data' was 'okay' for these, but let's make it explicit.

-- We keep the existing policies for: trips, routes, route_stops, bouse, branches, bus_classes
-- Because customers need to SELECT them.
-- However, we must ensure they CANNOT see internal fields if any (Postgres RLS is row-level, not column-level).
-- Assuming schema doesn't have "hidden_cost" on trips table. If it does, we'd need Security Definer Views.
-- For now, verifying that 'can_view_data' (the old function) is effectively:
-- "Public OR Admin OR PartnerOwner" -> This is correct for TRIPS.

-- BUT, let's rename/re-verify the function used for them to be clear it's a "Public Read" policy.
-- function `can_view_data` (Old) basically allowed everyone. 
-- We will leave it for public tables but ensure it's NOT used for private ones (which we did in step 2).

-- 4. Fix BOOKINGS Table (Hybrid)
-- Bookings are tricky. 
-- Customers need to see THEIR OWN bookings.
-- Partners need to see THEIR TRIPS' bookings.
-- Admins see all.
-- Public/Anonymous -> NONE.

DROP POLICY IF EXISTS "Unified view access for bookings" ON public.bookings;
CREATE POLICY "Strict hybrid access for bookings" ON public.bookings 
FOR SELECT 
USING (
    -- 1. My own booking (Customer/User)
    (user_id IN (SELECT user_id FROM public.users WHERE auth_id = auth.uid())) 
    OR 
    -- 2. Booking on my trip (Partner/Employee) - Using Strict Check
    EXISTS (
        SELECT 1 FROM public.trips t 
        WHERE t.trip_id = public.bookings.trip_id 
        AND public.can_access_private_data(t.partner_id)
    )
    OR
    -- 3. Admin (Handled by can_access_private_data internal check or global admin policy)
    (public.is_admin())
);

-- Helper for Admin check if not exists
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN
LANGUAGE sql
STABLE
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.user_roles 
    WHERE user_id = auth.uid() AND role = 'admin'
  );
$$;

COMMIT;
